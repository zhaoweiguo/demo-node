<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>D3 -- line</title>
  <style>
    * {
      box-sizing: border-box;
    }

    p, div {
      padding: 0;
      margin: 0;
    }

    svg {
      border: 1px solid;
    }

    .line-box {
      width: 100%;
      height: 200px;
    }

    .line-chart-d3 {
      position: relative;
    }

    .chart-title {
      position: absolute;
      font-size: 20px;
      color: #333;
    }

    .legends-group, .tips-content, .back-group {
      position: absolute;
      font-size: 12px;
    }

    .tips-content {
      display: none;
      padding: 5px;
      border-radius: 4px;
      min-width: 100px;
      max-width: 200px;
      background-color: rgba(0, 0, 0, .4);
      color: #fff;
    }

    .legends-group .legend-item {
      display: inline-block;
      color: #333;
      padding-left: 10px;
    }

    .legends-group .legend-item .legend-i, .tips-content .tip-item .tip-i {
      display: inline-block;
      vertical-align: middle;
      margin-right: 5px;
    }

    .legends-group .legend-item .legend-i {
      opacity: 1;
      width: 23px;
      height: 13px;
      border-radius: 3px;
      cursor: pointer;
    }

    .tips-content .tip-item .tip-i {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .back-group {
      display: none;
      top: 0;
      right: 0;
      background: rgba(255, 255, 255, .8);
      padding: 0px 8px;
      border: 1px solid #E8E8E8;
      border-radius: 3px;
      outline: none;
      cursor: pointer;
      color: #35404D;
    }

    .back-group:hover {
      color: #548DD8;
      border-color: #5B97E5;
    }

  </style>
</head>
<body>
<div class="d3-container">
  <div class="line-box">

    <div class="line-chart-d3">
      <div class="chart-title"></div>
      <div class="legends-group"></div>
      <div class="tips-content"></div>
      <button class="back-group">返回</button>
    </div>

  </div>
</div>
</body>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
  /**
   * 折线图
   * 0、标题，tip【tip可操作，点击控制展示折线数量】
   * 1、路径、区域、圆点
   * 2、坐标轴【水平x，垂直y，多y轴】，自适应时，更改值域，使用drag或者zoom时，更改定义域，超出部分隐藏
   * 3、drag，拖动小方块，更改水平x坐标轴的定义域来更改图形。ps: drag本身有一个坐标轴，只有自适应时更改值域
   * 4、zoom，鼠标绘制选区，选区内容放大。
   * 5、自适应，获取width，更改盒子宽度以及水平轴值域
   * */

    // 用户指定
  let paddingT = 60
  let paddingB = 60
  let paddingL = 60
  let paddingR = 60
  let lineData = {
    'padding': {
      left: 60,
      right: 60,
      top: 60,
      bottom: 60
    },
    'tips': true,
    'drag': true,
    'zoom': true,
    'title': 'QPS',
    'legend': {
      'show': true,
      'data': ['WRITE', 'READ']
    },
    'yAxis': {
      'title': 'GDP',
      'multi': false
    },
    'xAxis': {
      'title': '日期',
      'data': ['2017-06-22 17:01:16', '2017-06-22 17:01:36', '2017-06-22 17:01:56', '2017-06-22 17:02:16', '2017-06-22 17:02:36', '2017-06-22 17:02:56', '2017-06-22 17:03:16', '2017-06-22 17:03:36', '2017-06-22 17:03:56', '2017-06-22 17:04:16', '2017-06-22 17:04:36', '2017-06-22 17:04:56', '2017-06-22 17:05:16', '2017-06-22 17:05:36', '2017-06-22 17:05:56', '2017-06-22 17:06:16', '2017-06-22 17:06:36', '2017-06-22 17:06:56', '2017-06-22 17:07:16', '2017-06-22 17:07:36', '2017-06-22 17:07:56', '2017-06-22 17:08:16', '2017-06-22 17:08:36', '2017-06-22 17:08:56', '2017-06-22 17:09:16', '2017-06-22 17:09:36', '2017-06-22 17:09:56', '2017-06-22 17:10:16', '2017-06-22 17:10:36', '2017-06-22 17:10:56', '2017-06-22 17:11:16', '2017-06-22 17:11:36', '2017-06-22 17:11:56', '2017-06-22 17:12:16', '2017-06-22 17:12:36', '2017-06-22 17:12:56', '2017-06-22 17:13:16', '2017-06-22 17:13:36', '2017-06-22 17:13:56', '2017-06-22 17:14:16', '2017-06-22 17:14:36', '2017-06-22 17:14:56', '2017-06-22 17:15:16', '2017-06-22 17:15:36', '2017-06-22 17:15:56', '2017-06-22 17:16:16', '2017-06-22 17:16:36', '2017-06-22 17:16:56', '2017-06-22 17:17:16', '2017-06-22 17:17:36']
    },
    'series': [
      [{'data': 3356, 'time': '2017-06-22 17:01:16'}, {
        'data': 3338,
        'time': '2017-06-22 17:01:36'
      }, {'data': 2646, 'time': '2017-06-22 17:01:56'}, {
        'data': 3379,
        'time': '2017-06-22 17:02:16'
      }, {'data': 4872, 'time': '2017-06-22 17:02:36'}, {
        'data': 3584,
        'time': '2017-06-22 17:02:56'
      }, {'data': 1985, 'time': '2017-06-22 17:03:16'}, {
        'data': 2661,
        'time': '2017-06-22 17:03:36'
      }, {'data': 2921, 'time': '2017-06-22 17:03:56'}, {
        'data': 4087,
        'time': '2017-06-22 17:04:16'
      }, {'data': 4514, 'time': '2017-06-22 17:04:36'}, {
        'data': 251,
        'time': '2017-06-22 17:04:56'
      }, {'data': 2592, 'time': '2017-06-22 17:05:16'}, {
        'data': 5846,
        'time': '2017-06-22 17:05:36'
      }, {'data': 5508, 'time': '2017-06-22 17:05:56'}, {
        'data': 4787,
        'time': '2017-06-22 17:06:16'
      }, {'data': 3246, 'time': '2017-06-22 17:06:36'}, {
        'data': 2543,
        'time': '2017-06-22 17:06:56'
      }, {'data': 3258, 'time': '2017-06-22 17:07:16'}, {
        'data': 4142,
        'time': '2017-06-22 17:07:36'
      }, {'data': 5821, 'time': '2017-06-22 17:07:56'}, {
        'data': 2585,
        'time': '2017-06-22 17:08:16'
      }, {'data': 35, 'time': '2017-06-22 17:08:36'}, {
        'data': 1300,
        'time': '2017-06-22 17:08:56'
      }, {'data': 4649, 'time': '2017-06-22 17:09:16'}, {
        'data': 2115,
        'time': '2017-06-22 17:09:36'
      }, {'data': 701, 'time': '2017-06-22 17:09:56'}, {
        'data': 1965,
        'time': '2017-06-22 17:10:16'
      }, {'data': 4072, 'time': '2017-06-22 17:10:36'}, {
        'data': 1592,
        'time': '2017-06-22 17:10:56'
      }, {'data': 2367, 'time': '2017-06-22 17:11:16'}, {
        'data': 175,
        'time': '2017-06-22 17:11:36'
      }, {'data': 2757, 'time': '2017-06-22 17:11:56'}, {
        'data': 3794,
        'time': '2017-06-22 17:12:16'
      }, {'data': 1629, 'time': '2017-06-22 17:12:36'}, {
        'data': 4911,
        'time': '2017-06-22 17:12:56'
      }, {'data': 4976, 'time': '2017-06-22 17:13:16'}, {
        'data': 245,
        'time': '2017-06-22 17:13:36'
      }, {'data': 3648, 'time': '2017-06-22 17:13:56'}, {
        'data': 4198,
        'time': '2017-06-22 17:14:16'
      }, {'data': 1248, 'time': '2017-06-22 17:14:36'}, {
        'data': 5314,
        'time': '2017-06-22 17:14:56'
      }, {'data': 1592, 'time': '2017-06-22 17:15:16'}, {
        'data': 1253,
        'time': '2017-06-22 17:15:36'
      }, {'data': 747, 'time': '2017-06-22 17:15:56'}, {
        'data': 2343,
        'time': '2017-06-22 17:16:16'
      }, {'data': 3370, 'time': '2017-06-22 17:16:36'}, {
        'data': 3966,
        'time': '2017-06-22T17:16:56'
      }, {
        'data': 1075, 'time': '2017-06-22 17:17:16'
      }, {'data': 2753, 'time': '2017-06-22 17:17:36'}
      ],
      [{'data': 3256, 'time': '2017-06-22 17:01:16'}, {
        'data': 1338,
        'time': '2017-06-22 17:01:36'
      }, {'data': 4646, 'time': '2017-06-22 17:01:56'}, {
        'data': 6379,
        'time': '2017-06-22 17:02:16'
      }, {'data': 2872, 'time': '2017-06-22 17:02:36'}, {
        'data': 9584,
        'time': '2017-06-22 17:02:56'
      }, {'data': 6385, 'time': '2017-06-22 17:03:16'}, {
        'data': 1661,
        'time': '2017-06-22 17:03:36'
      }, {'data': 2921, 'time': '2017-06-22 17:03:56'}, {
        'data': 3087,
        'time': '2017-06-22 17:04:16'
      }, {'data': 9514, 'time': '2017-06-22 17:04:36'}, {
        'data': 2251,
        'time': '2017-06-22 17:04:56'
      }, {'data': 9592, 'time': '2017-06-22 17:05:16'}, {
        'data': 1846,
        'time': '2017-06-22 17:05:36'
      }, {'data': 9508, 'time': '2017-06-22 17:05:56'}, {
        'data': 2787,
        'time': '2017-06-22 17:06:16'
      }, {'data': 7246, 'time': '2017-06-22 17:06:36'}, {
        'data': 2543,
        'time': '2017-06-22 17:06:56'
      }, {'data': 4258, 'time': '2017-06-22 17:07:16'}, {
        'data': 5142,
        'time': '2017-06-22 17:07:36'
      }, {'data': 6821, 'time': '2017-06-22 17:07:56'}, {
        'data': 1585,
        'time': '2017-06-22 17:08:16'
      }, {'data': 435, 'time': '2017-06-22 17:08:36'}, {
        'data': 6300,
        'time': '2017-06-22 17:08:56'
      }, {'data': 649, 'time': '2017-06-22 17:09:16'}, {
        'data': 3115,
        'time': '2017-06-22 17:09:36'
      }, {'data': 701, 'time': '2017-06-22 17:09:56'}, {
        'data': 4965,
        'time': '2017-06-22 17:10:16'
      }, {'data': 4072, 'time': '2017-06-22 17:10:36'}, {
        'data': 5592,
        'time': '2017-06-22 17:10:56'
      }, {'data': 5367, 'time': '2017-06-22 17:11:16'}, {
        'data': 2875,
        'time': '2017-06-22 17:11:36'
      }, {'data': 1757, 'time': '2017-06-22 17:11:56'}, {
        'data': 9794,
        'time': '2017-06-22 17:12:16'
      }, {'data': 2629, 'time': '2017-06-22 17:12:36'}, {
        'data': 6911,
        'time': '2017-06-22 17:12:56'
      }, {'data': 3976, 'time': '2017-06-22 17:13:16'}, {
        'data': 2245,
        'time': '2017-06-22 17:13:36'
      }, {'data': 9648, 'time': '2017-06-22 17:13:56'}, {
        'data': 2198,
        'time': '2017-06-22 17:14:16'
      }, {'data': 7248, 'time': '2017-06-22 17:14:36'}, {
        'data': 7014,
        'time': '2017-06-22 17:14:56'
      }, {'data': 1992, 'time': '2017-06-22 17:15:16'}, {
        'data': 5253,
        'time': '2017-06-22 17:15:36'
      }, {'data': 2747, 'time': '2017-06-22 17:15:56'}, {
        'data': 3343,
        'time': '2017-06-22 17:16:16'
      }, {'data': 4370, 'time': '2017-06-22 17:16:36'}, {
        'data': 5966,
        'time': '2017-06-22T17:16:56'
      }, {
        'data': 4075, 'time': '2017-06-22 17:17:16'
      }, {'data': 8753, 'time': '2017-06-22 17:17:36'}
      ]
    ]
  }

  let color = d3.scaleOrdinal(d3.schemeCategory20)

  // 全局变量
  let width = parseInt(d3.select('.line-box').style('width'))
  let height = parseInt(d3.select('.line-box').style('height'))
  let lineWidth = width - paddingL - paddingR
  let lineHeight = height - paddingT - paddingB
  let svg = d3.select('.line-chart-d3')
    .append('svg')
    .attr('width', width)
    .attr('height', height)
  // 定义图表组, 坐标系组, legend组, tip组
  let chartG, xAxisG, yAxisG, legendsG, tipsG, dragG
  // 时间比例尺, 线性比例尺, 坐标轴, 多y轴
  let xScale = d3.scaleTime()
      .domain([new Date(d3.min(lineData.xAxis.data)), new Date(d3.max(lineData.xAxis.data))])
      .range([0, lineWidth]),
    dragScale = xScale.copy(), // 用来控制底部水平矩形轴，定义域一直不变，自适应时，值域变
    yScale = d3.scaleLinear()
      .domain([0, getMax(1)])
      .range([lineHeight, 0]),
    y0Scale

  // 公共方法 -->获取指定长度数组的最大值
  function getMax (type, startIdx, endIdx) {
    startIdx = startIdx || 0
    endIdx = endIdx || lineData.series[type].length
    let newArr = lineData.series[type].slice(startIdx, endIdx)
    let itemMax = d3.max(newArr, (d) => {
      return d.data
    })
    return itemMax
  }
  // 公共方法 -->返回指定长度的数组, length为除去0的个数，包含末尾
  function getData (arr, length) {
    let newArr = [arr[0]]
    let step = arr.length / length
    for (let i = 1; i <= length; i++) {
      if (i === length) {
        newArr.push(arr[arr.length - 1])
      } else {
        newArr.push(arr[parseInt(i * step)])
      }
    }
    return newArr
  }
  // 公共方法 -->获取指定数据对应的index
  let bisect = d3.bisector(function (d) {
    return new Date(d)
  }).left

  check() // 判断参数是否存在, 单个y还是多个等
  media() // 自适应处理

  function check () {
    if (lineData.title) {
      drawTitle() // 绘制title
    }

    if (lineData.legend.show && lineData.legend.data.length > 0) {
      drawLegend() // 绘制legend
    }

    if (lineData.yAxis.multi) {
      // multi === true
      y0Scale = d3.scaleLinear()
        .domain([0, getMax(0)])
        .range([lineHeight, 0])

      y0Axis = d3.axisRight()
        .scale(y0Scale)
        .ticks(5)
      // 绘制y轴
      y0AxisG = svg.select('.y0Axis')
        .call(y0Axis)
        .attr('transform', 'translate(' + width - paddingR + ',' + paddingT + ')')
      if (y0AxisG.empty()) {
        y0AxisG = svg.append('g')
          .call(y0Axis)
          .attr('class', 'y0Axis')
          .attr('transform', 'translate(' + (width - paddingR) + ',' + paddingT + ')')
          .append('text')
          .text(lineData.yAxis.title)
          .attr('stroke-width', 0)
          .attr('fill', 'black')
          .attr('text-anthor', 'middle')
      }
    }
    drawAxis() // 绘制坐标系
    drawLine() // 绘制折线

    if (lineData.tips) {
      drawTips() // tips控制
    }

    if (lineData.drag) {
      chartDrag() // 时间滑块控制 chartDrag与chartZoom最好值选择用一个
    }

    if (lineData.zoom) {
      chartZoom() // 鼠标滚轮以及触摸板控制
    }
  }

  function drawTitle () {
    d3.select('.chart-title')
      .text(lineData.title)
      .style('top', () => {
        let top = (paddingT - parseInt(d3.select('.chart-title').style('height'))) / 2
        return top + 'px'
      })
      .style('left', paddingL + 'px')
  }
  function drawLegend () {
    legendsG = d3.select('.legends-group')

    let legendItemG = legendsG.selectAll('.legend-item').data(lineData.legend.data)
    let enterLegendItem = legendItemG.enter()

    // update
    legendItemG
      .select('.legend-i')
      .style('background-color', (d, i) => {
        return color(i)
      })
    legendItemG
      .selectAll('legend-text')
      .text((d) => {
        return d
      })
    // add
    let legendDiv = enterLegendItem.append('div')
      .attr('class', (d, i) => {
        return 'legend-item legend-item' + i
      })
      .on('mousemove', function (d, i) {
        d3.select('.chart-group').select('.circle-group')
          .select('.line-ciecle-item' + i).selectAll('circle')
          .transition()
          .duration(100)
          .attr('r', 5)
      })
      .on('mouseout', function (d, i) {
        d3.select('.chart-group').select('.circle-group')
          .select('.line-ciecle-item' + i).selectAll('circle')
          .transition()
          .duration(100)
          .attr('r', 2.5)
      })
    legendDiv.append('i')
      .attr('class', 'legend-i')
      .style('background-color', (d, i) => {
        return color(i)
      })
      .on('click', function (d, i) {
        let opacity = parseInt(d3.select(this).style('opacity'))
        d3.select(this).style('opacity', (opacity === 1) ? 0.5 : 1)

        d3.select('.chart-group').select('.area-group')
          .select('.line-area-item' + i)
          .transition()
          .duration(200)
          .attr('opacity', (opacity === 1) ? 0 : 1)
        d3.select('.chart-group').select('.path-group')
          .select('.line-path-item' + i)
          .transition()
          .duration(200)
          .attr('opacity', (opacity === 1) ? 0 : 1)
        d3.select('.chart-group').select('.circle-group')
          .select('.line-ciecle-item' + i)
          .transition()
          .duration(200)
          .attr('opacity', (opacity === 1) ? 0 : 1)
      })
    legendDiv.append('span')
      .attr('class', 'legend-text')
      .text((d) => {
        return d
      })
    legendsG
      .style('top', () => {
        let top = (paddingT - parseInt(d3.select('.legend-item').style('height'))) / 2
        return top + 'px'
      })
      .style('right', paddingR + 'px')

    // del
    legendItemG.exit().remove()
  }

  function drawAxis () {
    // x轴坐标系设置

    let differ = getTimeDiffer(d3.min(lineData.xAxis.data), d3.max(lineData.xAxis.data))

    let xAxis = d3.axisBottom(xScale)
      .ticks(d3[differ.type].every(differ.value))
      .tickFormat(d3.timeFormat('%Y-%m-%d %H:%M:%S'))
    // 绘制x轴
    xAxisG = svg.select('.xAxis')
      .call(xAxis)
      .attr('transform', 'translate(' + paddingL + ',' + (height - paddingB) + ')')
    xAxisG.selectAll('.xAxis-title')
      .attr('transform', 'translate(' + lineWidth + ', 0)')
    xAxisG.selectAll('#clip-xAxisG').select('rect')
      .attr('width', lineWidth + paddingR)
    if (xAxisG.empty()) {
      xAxisG = svg.append('g')
        .call(xAxis)
        .attr('class', 'xAxis')
        .attr('transform', 'translate(' + paddingL + ',' + (height - paddingB) + ')')
      xAxisG.append('text')
        .attr('class', 'xAxis-title')
        .text(lineData.xAxis.title)
        .attr('stroke-width', 0)
        .attr('fill', 'black')
        .attr('transform', 'translate(' + lineWidth + ', 0)')
        .attr('dy', '1rem')
        .attr('text-anchor', 'start')
      // 隐藏多余的内容，主要用在drag时，防止x轴文字出边界
      xAxisG.append('defs')
        .append('clipPath')
        .attr('id', 'clip-xAxisG')
        .append('rect')
        .attr('width', lineWidth + paddingR)
        .attr('height', 20)
    }
    xAxisG.attr('clip-path', 'url(#clip-xAxisG)')

    // y轴坐标系设置
    let yAxis = d3.axisLeft()
      .scale(yScale)
      .ticks(5)
    // 绘制y轴
    yAxisG = svg.select('.yAxis')
      .call(yAxis)
      .attr('transform', 'translate(' + paddingL + ',' + paddingT + ')')
    if (yAxisG.empty()) {
      yAxisG = svg.append('g')
        .call(yAxis)
        .attr('class', 'yAxis')
        .attr('transform', 'translate(' + paddingL + ',' + paddingT + ')')
        .append('text')
        .text(lineData.yAxis.title)
        .attr('stroke-width', 0)
        .attr('fill', 'black')
        .attr('text-anthor', 'middle')
    }
  }
  function drawLine () {
    chartG = svg.selectAll('.chart-group')
    chartG.selectAll('#clip').select('rect')
      .attr('width', lineWidth)
      .attr('height', lineHeight + 5)
    if (chartG.empty()) {
      chartG = svg.append('g')
        .attr('class', 'chart-group')
      // 隐藏多余的内容
      chartG.append('defs')
        .append('clipPath')
        .attr('id', 'clip')
        .append('rect')
        .attr('width', lineWidth)
        .attr('height', lineHeight + 5)
        .attr('x', paddingL)
        .attr('y', paddingT - 5)
      chartG.attr('clip-path', 'url(#clip)')
      chartG.append('g')
        .attr('class', 'area-group')
      chartG.append('g')
        .attr('class', 'path-group')
      chartG.append('g')
        .attr('class', 'circle-group')
    }
    drawArea() // 绘制路径背景 -----> 动画有问题
    drawPath() // 绘制路径
    drawCircle() // 绘制圆点
  }
  function drawArea () {
    let areaG = chartG.selectAll('.area-group')
    // 区域生成器，设置x y y0的取值
    let areaLine = d3.area()
      .x((d) => {
        return xScale(new Date(d.time))
      })
      .y0(() => {
        return height - paddingB
      })

    let areaPath = areaG.selectAll('.line-area-item').data(lineData.series)
    let enterAreaPath = areaPath.enter()
    // update
    areaPath.attr('d', (d, i) => {
      if (lineData.yAxis.multi && i === 0) {
        areaLine.y1((d) => {
          return y0Scale(d.data) + paddingT
        })
      } else {
        areaLine.y1((d) => {
          return yScale(d.data) + paddingT
        })
      }
      return areaLine(d)
    })
    // add
    enterAreaPath.append('path')
      .attr('class', (d, i) => {
        return 'line-area-item line-area-item' + i
      })
      .attr('d', (d, i) => {
        if (lineData.yAxis.multi && i === 0) {
          areaLine.y1((d) => {
            return y0Scale(d.data) + paddingT
          })
        } else {
          areaLine.y1((d) => {
            return yScale(d.data) + paddingT
          })
        }
        return areaLine(d)
      })
      .attr('stroke', 'none')
      .attr('fill', (d, i) => {
        return color(i)
      })
      .attr('fill-opacity', '.3')
      .attr('transform', 'translate(' + paddingL + ')')
    // del
    areaPath.exit().remove()
  }
  function drawPath () {
    let pathG = chartG.selectAll('.path-group')
    // 线段生成器，设置x y的取值
    let line = d3.line()
      .x((d) => {
        return xScale(new Date(d.time))
      })

    let path = pathG.selectAll('.line-path-item').data(lineData.series)
    let enterPath = path.enter()
    // update
    path
      .attr('d', (d, i) => {
        if (lineData.yAxis.multi && i === 0) {
          line.y((dy) => {
            return y0Scale(dy.data) + paddingT
          })
        } else {
          line.y((dy) => {
            return yScale(dy.data) + paddingT
          })
        }
        return line(d)
      })
      .attr('stroke-dasharray', function () {
        return this.getTotalLength()
      })
      .attr('stroke-dashoffset', function () {
        let lastOffSet = d3.select(this).attr('data-offset')
        d3.select(this).attr('data-offset', this.getTotalLength())
        let newOffSet = this.getTotalLength() - lastOffSet
        return newOffSet > 0 ? newOffSet : 0
      })
      .transition()
      .duration(500)
      .attr('stroke-dashoffset', 0)

    enterPath.append('path').attr('class', (d, i) => {
      return 'line-path-item line-path-item' + i
    })
      .attr('d', (d, i) => {
        if (lineData.yAxis.multi && i === 0) {
          line.y((dy) => {
            return y0Scale(dy.data) + paddingT
          })
        } else {
          line.y((dy) => {
            return yScale(dy.data) + paddingT
          })
        }
        return line(d)
      })
      .attr('stroke', function (d, i) {
        return color(i)
      })
      .attr('fill', 'none')
      .attr('transform', 'translate(' + paddingL + ')')
      .attr('stroke-dasharray', function () {
        d3.select(this).attr('data-offset', this.getTotalLength())
        return this.getTotalLength()
      })
      .attr('stroke-dashoffset', function () {
        return this.getTotalLength()
      })
      .transition()
      .duration(1000)
      .attr('stroke-dashoffset', 0)

    // del
    path.exit().remove()
  }
  function drawCircle () {
    let circleG = chartG.selectAll('.circle-group')

    let circleItemG = circleG.selectAll('.line-ciecle-item')
      .data(lineData.series)
    let enterCircleItemG = circleItemG.enter()

    // add
    enterCircleItemG.append('g')
      .attr('class', (d, i) => {
        return 'line-ciecle-item line-ciecle-item' + i
      })
      .attr('transform', 'translate(' + paddingL + ', ' + paddingT + ')')
      .attr('stroke', (d, i) => {
        return color(i)
      })
      .attr('fill', '#fff')
    // del
    circleItemG.exit().remove()

    lineData.series.forEach((item, idx) => {
      item = getData(item, xScale.ticks(5).length + 1) // 与 x轴个数同步

      let parentG = svg.selectAll('.line-ciecle-item' + idx)
      let circle = parentG.selectAll('circle')
        .data(item)
      let enterCircle = circle.enter()
      // update
      circle.attr('cx', (d) => {
        return xScale(new Date(d.time))
      })
        .attr('cy', (d) => {
          if (lineData.yAxis.multi && idx === 0) {
            return y0Scale(d.data)
          } else {
            return yScale(d.data)
          }
        })
      // add
      enterCircle.append('circle')
        .attr('cx', (d) => {
          return xScale(new Date(d.time))
        })
        .attr('cy', (d) => {
          if (lineData.yAxis.multi && idx === 0) {
            return y0Scale(d.data)
          } else {
            return yScale(d.data)
          }
        })
        .attr('r', 2.5)
        .style('cursor', 'pointer')
        .attr('opacity', 0)
        .transition()
        .duration(700)
        .delay(300)
        .attr('opacity', 1)
      // del
      circle.exit().remove()
    })
  }

  function drawTips () {
    tipsG = svg.selectAll('.tips-group')
    if (tipsG.empty()) {
      tipsG = svg.append('g')
        .attr('class', 'tips-group')

    }
    let tipsRect = tipsG.selectAll('.mousemove-rect')
    if (tipsRect.empty()) {
      tipsRect = tipsG.append('rect')
        .attr('class', 'mousemove-rect')
    }
    tipsRect.attr('width', lineWidth)
      .attr('height', lineHeight)
      .attr('x', paddingL)
      .attr('y', paddingT)
      .attr('fill', 'none')
      .style('pointer-events', 'all')
      .on('mouseover', function () {
        d3.select('.tips-content').transition().duration(200).style('display', 'block')
        d3.select('.tips-line-groups').transition().duration(200).style('display', 'block')
      })
      .on('mouseout', function () {
        d3.select('.tips-content').transition().duration(200).style('display', 'none')
        d3.select('.tips-line-groups').transition().duration(200).style('display', 'none')
      })
      .on('mousemove', showTip)
  }
  function showTip () {
    // 获取x轴坐标
    let x0 = xScale.invert(d3.mouse(this)[0] - paddingL),
      i = bisect(lineData.xAxis.data, x0),
      d0 = lineData.xAxis.data[i - 1],
      d1 = lineData.xAxis.data[i],
      d = new Date((x0 - d0) > (d1 - x0) ? d1 : d0)

    // 获取交点 y轴坐标
    let points = []
    lineData.series.forEach((item, idx) => {
      item.forEach((ditem) => {
        if (Date.parse(ditem.time) === Date.parse(d)) {
          points.push(ditem.data)
        }
      })
    })

    // 绘制垂直线以及圆点
    let tipsLineG = tipsG.selectAll('.tips-line-groups')
    tipsLineG.selectAll('.tips-line').attr('x1', xScale(d) + paddingL)
      .attr('x2', xScale(d) + paddingL)
    if (tipsLineG.empty()) {
      tipsG.append('g')
        .attr('class', 'tips-line-groups')
        .append('line')
        .attr('class', 'tips-line')
        .attr('x1', xScale(d))
        .attr('y1', paddingT)
        .attr('x2', xScale(d))
        .attr('y2', height - paddingB)
        .attr('stroke', '#999')
    }
    let tipsLineCircle = tipsLineG.selectAll('.tips-circle').data(points)
    tipsLineCircle
      .attr('cx', xScale(d) + paddingL)
      .attr('cy', (d) => {
        return yScale(d) + paddingT
      })
      .attr('opacity', (d, i) => {
        if (!lineData.legend.show || lineData.legend.data.length <= 0) {
          return 1
        } else {
          let opacity = d3.selectAll('.legend-item' + i).selectAll('.legend-i').style('opacity')
          return (parseInt(opacity) === 1) ? 1 : 0
        }
      })
    let enterTipsLineCircle = tipsLineCircle.enter()
    enterTipsLineCircle.append('circle')
      .attr('class', 'tips-circle')
      .attr('r', 5)
      .attr('cx', xScale(d) + paddingL)
      .attr('cy', (d) => {
        return yScale(d) + paddingT
      })
      .attr('stroke', (d, i) => {
        return color(i)
      })
      .attr('fill', '#fff')
      .attr('opacity', (d, i) => {
        if (!lineData.legend.show || lineData.legend.data.length <= 0) {
          return 1
        } else {
          let opacity = d3.selectAll('.legend-item' + i).selectAll('.legend-i').style('opacity')
          return (parseInt(opacity) === 1) ? 1 : 0
        }
      })
      .on('mouseover', function () {
        d3.select('.tips-content').transition().duration(200).style('display', 'block')
        d3.select('.tips-line-groups').transition().duration(200).style('display', 'block')
      })
      .on('mouseout', function () {
        d3.select('.tips-content').transition().duration(200).style('display', 'none')
        d3.select('.tips-line-groups').transition().duration(200).style('display', 'none')
      })
    tipsLineCircle.exit().remove()

    // tip框填充相应文字数据
    let timeFormat = d3.timeFormat('%Y-%m-%d %H:%M:%S')
    let tipsContent = d3.selectAll('.tips-content')
    let tipsTitle = tipsContent.selectAll('.tips-title')
    tipsTitle.text('时间: ' + timeFormat(d))
    if (tipsTitle.empty()) {
      tipsContent.append('p')
        .attr('class', 'tips-title')
        .text('时间: ' + timeFormat(d))
    }
    let tipItem = tipsContent.selectAll('.tip-item').data(points)
    // update
    tipItem.style('display', (d, i) => {
      if (!lineData.legend.show || lineData.legend.data.length <= 0) {
        return 'block'
      } else {
        let opacity = d3.selectAll('.legend-item' + i).selectAll('.legend-i').style('opacity')
        return (parseInt(opacity) === 1) ? 'block' : 0
      }
    })
    tipItem.select('i')
      .style('background-color', (d, i) => {
        return color(i)
      })
    tipItem.select('span')
      .text((d, i) => {
        if (!lineData.legend.show || lineData.legend.data.length <= 0) {
          return d
        } else {
          return lineData.legend.data[i] + ' : ' + d
        }
      })
    // add
    let enterTipItem = tipItem.enter()
    let tipItemDiv = enterTipItem
      .append('div')
      .attr('class', 'tip-item')
      .style('display', (d, i) => {
        if (!lineData.legend.show || lineData.legend.data.length <= 0) {
          return 'block'
        } else {
          let opacity = d3.selectAll('.legend-item' + i).selectAll('.legend-i').style('opacity')
          return (parseInt(opacity) === 1) ? 'block' : 0
        }
      })
    tipItemDiv.append('i')
      .attr('class', 'tip-i')
      .style('background-color', (d, i) => {
        return color(i)
      })
    tipItemDiv.append('span')
      .attr('class', 'tip-text')
      .text((d, i) => {
        if (!lineData.legend.show || lineData.legend.data.length <= 0) {
          return d
        } else {
          return lineData.legend.data[i] + ' : ' + d
        }
      })
    // del
    tipItem.exit().remove()

    // tip框位置处理 边界处理
    let svgCenterW = width / 2, svgCenterH = height / 2, tipsL, tipsT
    if (d3.mouse(this)[0] > svgCenterW) {
      tipsL = d3.mouse(this)[0] - parseInt(tipsContent.style('width')) - 20 + 'px'
    } else {
      tipsL = d3.mouse(this)[0] + 20 + 'px'
    }
    if (d3.mouse(this)[1] > svgCenterH) {
      tipsT = d3.mouse(this)[1] - parseInt(tipsContent.style('height')) - 20 + 'px'
    } else {
      tipsT = d3.mouse(this)[1] + 20 + 'px'
    }
    tipsContent.style('left', tipsL)
      .style('top', tipsT)
  }

  // 滑块
  function chartDrag () {
    dragG = svg.selectAll('.drag-group')
    if (dragG.empty()) {
      dragG = svg.append('g')
        .attr('class', 'drag-group')
    }
    // 矩形边框
    let dragRectBox = dragG.selectAll('.drag-rect-box')
    if (dragRectBox.empty()) {
      dragRectBox = dragG.append('rect')
        .attr('class', 'drag-rect-box')
    }
    dragRectBox.attr('width', lineWidth)
      .attr('height', 15)
      .attr('x', paddingL)
      .attr('y', height - paddingB / 2)
      .attr('stroke', '#E8E8E8')
      .attr('fill', 'none')

    // 蓝色矩形块 拖动
    let rectDrag = d3.drag()
      .on('start', function () {
        d3.select(this)
          .attr('data-mouse-x', d3.mouse(this)[0])
      })
      .on('drag', function () {
        let lastMouseX = d3.select(this).attr('data-mouse-x')
        let moveLength = parseFloat(d3.mouse(this)[0] - lastMouseX)
        let x = parseFloat(d3.select(this).attr('x')) + moveLength
        if (x <= paddingL) {
          x = paddingL
        } else if (x + parseFloat(d3.select(this).attr('width')) >= lineWidth + paddingL) {
          x = lineWidth - parseFloat(d3.select(this).attr('width')) + paddingL
        }
        // 矩形位置控制
        d3.select(this)
          .attr('x', x)
        d3.select(this).attr('data-mouse-x', d3.mouse(this)[0])

        // 滑块位置控制
        let rect0 = d3.select('.rect-box0')
        let rect1 = d3.select('.rect-box1')
        if (parseFloat(rect0.attr('x')) > parseFloat(rect1.attr('x'))) {
          rect0 = d3.select('.rect-box1')
          rect1 = d3.select('.rect-box0')
        }
        let x0 = dragScale.invert(x - paddingL)
        let x1 = dragScale.invert(x + parseFloat(d3.select(this).attr('width') - paddingL))
        rect0.attr('x', x)
          .attr('data-x', x)
          .attr('data-time', x0)
        rect1.attr('x', x + parseFloat(d3.select(this).attr('width')) - 10)
          .attr('data-x', x + parseFloat(d3.select(this).attr('width')) - 10)
          .attr('data-time', x1)

        // 计算x轴 y轴 新的定义域【】，值域不变
        let idxL = bisect(lineData.xAxis.data, x0)
        let idxR = bisect(lineData.xAxis.data, x1)
        xScale.domain([x0, x1])
        if (Math.abs(idxR - idxL) > 2)
          yScale.domain([0, getMax(1, idxL, idxR + 1)])
        drawAxis()
        drawLine()

      })
    // 矩形背景蓝色
    let dragRect = dragG.selectAll('.drag-rect')
    if (dragRect.empty()) {
      dragRect = dragG.append('rect')
        .attr('class', 'drag-rect')
    }
    dragRect
      .attr('width', () => {
        let width = lineWidth
        if (!d3.select('.rect-box0').empty()) {
          let xA = dragScale(new Date(d3.select('.rect-box0').attr('data-time'))) + paddingL
          let xB = dragScale(new Date(d3.select('.rect-box1').attr('data-time'))) + paddingL
          width = (xB - xA) > 0 ? xB - xA : xA - xB
        }
        return width
      })
      .attr('height', 15)
      .attr('x', () => {
        let x = paddingL
        if (!d3.select('.rect-box0').empty()) {
          let xA = dragScale(new Date(d3.select('.rect-box0').attr('data-time'))) + paddingL
          let xB = dragScale(new Date(d3.select('.rect-box1').attr('data-time'))) + paddingL
          x = (xB - xA) > 0 ? xA : xB
        }
        return x
      })
      .attr('y', height - paddingB / 2)
      .attr('stroke', 'none')
      .attr('fill', color(0))
      .attr('fill-opacity', 0.5)
      .style('cursor', 'pointer')
      .call(rectDrag)

    // 两端滑块 拖动
    let drag = d3.drag()
      .on('drag', function () {
        // 滑块位置控制
        let rectX = d3.mouse(this)[0]
        let rectDataTimeX = rectX - paddingL
        if (parseFloat(d3.mouse(this)[0]) <= parseFloat(paddingL)) {
          rectX = paddingL
          rectDataTimeX = rectX - paddingL
        } else if (parseFloat(d3.mouse(this)[0]) >= parseFloat(width - paddingR)) {
          rectX = width - paddingR - 10
          rectDataTimeX = rectX - paddingL + 10
        }
        d3.select(this).select('.rect-box')
          .attr('x', rectX)
          .attr('data-x', rectX)
          .attr('data-time', dragScale.invert(rectDataTimeX))

        // 控制条宽度以及位置更改
        let xA = dragScale(new Date(d3.select('.rect-box0').attr('data-time'))) + paddingL
        let xB = dragScale(new Date(d3.select('.rect-box1').attr('data-time'))) + paddingL
        d3.select('.drag-rect')
          .attr('width', (xB - xA) > 0 ? (xB - xA) : (xA - xB))
          .attr('x', (xB - xA) > 0 ? xA : xB)

        // 计算x轴 y轴 新的定义域【】，值域不变
        let x0 = new Date(d3.select('.rect-box0').attr('data-time')),
          x1 = new Date(d3.select('.rect-box1').attr('data-time')),
          idxL, idxR
        if (xA > xB) {
          x0 = new Date(d3.select('.rect-box1').attr('data-time'))
          x1 = new Date(d3.select('.rect-box0').attr('data-time'))
        }
        idxL = bisect(lineData.xAxis.data, x0)
        idxR = bisect(lineData.xAxis.data, x1)
        xScale.domain([x0, x1])

        if (Math.abs(idxR - idxL) > 2)
          yScale.domain([0, getMax(1, idxL, idxR + 1)])
        drawAxis()
        drawLine()
      })
    let rectData = [{x: paddingL}, {x: width - paddingR - 10}]
    let dragMark = dragG.selectAll('g').data(rectData)
    // update 自适应窗口 位置变化
    dragMark.select('.rect-box')
      .attr('x', function (d, i) {
        let x = dragScale(new Date(d3.select(this).attr('data-time'))) + paddingL
        if (i === 1) {
          x = x - 10
        }
        return x
      })
      .attr('data-x', function () {
        return dragScale(new Date(d3.select(this).attr('data-time'))) + paddingL
      })
    // add
    let enterDragMark = dragMark.enter()
    enterDragMark.append('g')
      .attr('class', (d, i) => {
        return 'drag-mark drag-mark' + i
      })
      .style('cursor', 'pointer')
      .call(drag)
      .append('rect')
      .attr('class', (d, i) => {
        return 'rect-box rect-box' + i
      })
      .attr('width', 10)
      .attr('height', 15)
      .attr('x', (d) => {
        return d.x
      })
      .attr('y', height - paddingB / 2)
      .attr('data-x', (d) => {
        return d.x
      })
      .attr('data-time', (d, i) => {
        let dataTime = i === 0 ? dragScale.invert(d.x - paddingL) : dragScale.invert(d.x - paddingL + 10)
        return dataTime
      })
      .attr('stroke', 'none')
      .attr('fill', color(0))

    dragMark.exit().remove()
  }
  // 事件控制【鼠标选区／鼠标滚轮／触摸板】
  function chartZoom () {
    // 鼠标选区放大缩小
    // 滚轮／触摸板放大缩小---transform
    let zoom = d3.zoom()
      .scaleExtent([1, 10])
      // .translateExtent([0, 0], [0, 0])
      .on('start', function (d, i) {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'mousedown') {
          mouseChange(0, d3.mouse(this))
        }
      })
      .on('zoom', function () {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'mousemove') {
          d3.select('.tips-content').transition().duration(200).style('display', 'none')
          d3.select('.tips-line-groups').transition().duration(200).style('display', 'none')
          mouseChange(1, d3.mouse(this))
        }
        /*if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'wheel') {
         wheelChange(d3.zoomTransform(this), d3.mouse(this))
         }*/
      })
      .on('end', function () {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'mouseup') {
          mouseChange(2, d3.mouse(this))
        }
      })
    svg.call(zoom)
      .on('dbclick.zoom', null)
  }
  // 鼠标选区
  function mouseChange (type, d) {
    let mouseG = svg.selectAll('.mouse-group')
    let mouseRect = mouseG.selectAll('.mouse-rect')
    if (mouseG.empty()) {
      mouseRect = svg.append('g')
        .attr('class', 'mouse-group')
        .append('rect')
        .attr('class', 'mouse-rect')
        .attr('fill', '#fff')
        .attr('stroke', '#ccc')
        .attr('opacity', .7)
        .attr('stroke-dasharray', '5, 5')
    }

    let dataX, dataY
    if (type === 0) {
      mouseRect.attr('x', d[0])
        .attr('y', d[1])
        .attr('width', 0)
        .attr('height', 0)
        .attr('data-x', d[0])
        .attr('data-y', d[1])
    } else if (type === 1) {
      dataX = mouseRect.attr('data-x')
      dataY = mouseRect.attr('data-y')
      let rectWidth = Math.abs(d[0] - dataX)
      let rectHeight = Math.abs(d[1] - dataY)
      mouseRect
        .attr('width', rectWidth <= 3 ? 0 : rectWidth)
        .attr('height', rectHeight <= 3 ? 0 : rectHeight)
        .attr('x', d[0] - dataX > 0 ? dataX : d[0])
        .attr('y', d[1] - dataY > 0 ? dataY : d[1])
    } else {
      dataX = mouseRect.attr('data-x')
      if (Math.abs(d[0] - dataX) <= 3) {
        mouseG.remove()
        return false
      }
      let x0 = xScale.invert(dataX - paddingL)
      let x1 = xScale.invert(d[0] - paddingL)
      if (dataX > d[0]) {
        x0 = xScale.invert(d[0] - paddingL)
        x1 = xScale.invert(dataX - paddingL)
      }
      xScale.domain([x0, x1])

      // 关联 drag
      if (!d3.select('.rect-box0').empty()) {
        // 滑块
        d3.select('.rect-box0')
          .attr('x', dragScale(new Date(x0)) + paddingL)
          .attr('data-x', dragScale(new Date(x0)) + paddingL)
          .attr('data-time', x0)
        d3.select('.rect-box1')
          .attr('x', dragScale(new Date(x1)) + paddingL - 10)
          .attr('data-x', dragScale(new Date(x1)) + paddingL - 10)
          .attr('data-time', x1)

        // 控制条宽度以及位置更改
        d3.select('.drag-rect')
          .attr('width', dragScale(new Date(x1)) - dragScale(new Date(x0)))
          .attr('x', dragScale(new Date(x0)) + paddingL)
      }

      mouseG.remove()
      drawAxis()
      drawLine()
      let backG = d3.selectAll('.back-group')
      backG.style('display', 'block')
        .style('right', paddingR + 'px')
        .style('top', paddingT + 'px')
        .on('click', function () {
          xScale
            .domain([new Date(d3.min(lineData.xAxis.data)), new Date(d3.max(lineData.xAxis.data))])
          drawAxis()
          drawLine()
          d3.select(this).style('display', 'none')
          // 关联 drag 滑块复原
          if (!d3.select('.rect-box0').empty()) {
            // 滑块
            d3.select('.rect-box0')
              .attr('x', paddingL)
              .attr('data-x', paddingL)
              .attr('data-time', new Date(d3.min(lineData.xAxis.data)))
            d3.select('.rect-box1')
              .attr('x', lineWidth + paddingL - 10)
              .attr('data-x', lineWidth + paddingL - 10)
              .attr('data-time', new Date(d3.max(lineData.xAxis.data)))

            // 控制条宽度以及位置更改
            d3.select('.drag-rect')
              .attr('width', lineWidth)
              .attr('x', paddingL)
          }
        })
    }
  }

  function media () {
    window.onresize = function () {
      let docWidth = document.body.clientWidth
      if (docWidth !== width) {
        width = document.body.clientWidth
        lineWidth = width - paddingL - paddingR
        svg.attr('width', width)
        xScale.range([0, lineWidth])
        dragScale.range([0, lineWidth])
        check()
      }
    }
  }

  function getTimeDiffer (date1, date2) {
    let differ = Math.abs(new Date(date1).getTime() - new Date(date2).getTime())
    let days = Math.floor(differ / (24 * 3600 * 1000))
    let leave1 = differ % (24 * 3600 * 1000)    //计算天数后剩余的毫秒数
    let hours = Math.floor(leave1 / (3600 * 1000))
    //计算相差分钟数
    let leave2 = leave1 % (3600 * 1000)        //计算小时数后剩余的毫秒数
    let minutes = Math.floor(leave2 / (60 * 1000))
    //计算相差秒数
    let leave3 = leave2 % (60 * 1000)      //计算分钟数后剩余的毫秒数
    let seconds = Math.round(leave3 / 1000)

    let axis, type, num = parseInt(lineWidth / 200)
    // 分配
    if (seconds !== 0) {
      axis = Math.floor(seconds / num)
      type = 'timeSecond'
    }
    if (minutes !== 0) {
      axis = Math.floor(minutes / num)
      type = 'timeMinute'
    }
    if (hours !== 0) {
      axis = Math.floor(hours / num)
      type = 'timeHour'
    }
    if (days !== 0) {
      axis = Math.floor(days / num)
      type = 'timeDay'
    }

    return {
      day: days,
      hours: hours,
      minutes: minutes,
      seconds: seconds,
      type: type,
      value: axis
    }
  }
</script>
</html>